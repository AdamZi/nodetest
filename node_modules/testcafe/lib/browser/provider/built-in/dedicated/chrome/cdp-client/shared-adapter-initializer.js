"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const execution_context_1 = __importDefault(require("./execution-context"));
const clients_manager_1 = require("./clients-manager");
const adapter_1 = require("../../../../../../shared/adapter");
const domUtils = __importStar(require("./utils/dom-utils"));
const positionUtils = __importStar(require("./utils/position-utils"));
const styleUtils = __importStar(require("./utils/style-utils"));
const eventUtils = __importStar(require("./utils/event-utils"));
const create_event_sequence_1 = __importDefault(require("./utils/create-event-sequence"));
const create_mouse_click_strategy_1 = __importDefault(require("./automations/click/create-mouse-click-strategy"));
adapter_1.initializeAdapter({
    PromiseCtor: Promise,
    nativeMethods: {
        setTimeout,
        clearTimeout,
        arrayIndexOf: Array.prototype.indexOf,
        arraySplice: Array.prototype.splice,
        arraySlice: Array.prototype.slice,
        arrayFilter: Array.prototype.filter,
        objectAssign: Object.assign,
        objectKeys: Object.keys,
        dateNow: Date.now,
    },
    scroll: async (el, opts) => {
        let currCxt = execution_context_1.default.current;
        let result = null;
        let margin = void 0;
        do {
            const { exceptionDetails, result: resultObj } = await clients_manager_1.getClient().Runtime.callFunctionOn({
                returnByValue: true,
                awaitPromise: true,
                executionContextId: execution_context_1.default.getCurrentContextId(),
                arguments: [{ objectId: el.objectId }, { value: opts }, { value: margin }],
                functionDeclaration: `function (el, opts) {
                    return window["%proxyless%"].scroll(el, opts);
                }`,
            });
            if (exceptionDetails)
                throw exceptionDetails;
            const scrollResult = resultObj.value;
            if (currCxt && currCxt !== currCxt.parent) {
                // TODO:
                //el           = findIframeByWindow(currCxt);
                currCxt = currCxt.parent;
                result = result !== null && result !== void 0 ? result : scrollResult.scrollWasPerformed;
                margin = scrollResult.maxScrollMargin;
                opts.offsetX = scrollResult.offsetX;
                opts.offsetY = scrollResult.offsetY;
            }
        } while (currCxt && currCxt !== currCxt.parent);
        return result;
    },
    browser: { isChrome: true },
    featureDetection: {
        isTouchDevice: false,
    },
    utils: {
        extend(target, ...args) {
            return Object.assign(target, ...args);
        },
    },
    createEventSequence: create_event_sequence_1.default,
    sendRequestToFrame: () => { },
    getElementExceptUI: positionUtils.getElementFromPoint,
    dom: domUtils,
    position: positionUtils,
    style: styleUtils,
    event: eventUtils,
    ensureMouseEventAfterScroll: () => Promise.resolve(),
    automations: {
        click: {
            createMouseClickStrategy: create_mouse_click_strategy_1.default,
        },
        _ensureWindowAndCursorForLegacyTests() {
        },
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLWFkYXB0ZXItaW5pdGlhbGl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvYnJvd3Nlci9wcm92aWRlci9idWlsdC1pbi9kZWRpY2F0ZWQvY2hyb21lL2NkcC1jbGllbnQvc2hhcmVkLWFkYXB0ZXItaW5pdGlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNEVBQW1EO0FBR25ELHVEQUE4QztBQUM5Qyw4REFBcUU7QUFHckUsNERBQThDO0FBQzlDLHNFQUF3RDtBQUN4RCxnRUFBa0Q7QUFDbEQsZ0VBQWtEO0FBQ2xELDBGQUFnRTtBQUNoRSxrSEFBdUY7QUFHdkYsMkJBQWlCLENBQUM7SUFDZCxXQUFXLEVBQUUsT0FBTztJQUVwQixhQUFhLEVBQUU7UUFDWCxVQUFVO1FBQ1YsWUFBWTtRQUNaLFlBQVksRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLE9BQU87UUFDckMsV0FBVyxFQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtRQUNwQyxVQUFVLEVBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLO1FBQ25DLFdBQVcsRUFBRyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU07UUFDcEMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1FBQzNCLFVBQVUsRUFBSSxNQUFNLENBQUMsSUFBSTtRQUN6QixPQUFPLEVBQU8sSUFBSSxDQUFDLEdBQUc7S0FDekI7SUFFRCxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQWMsRUFBRSxJQUFtQixFQUFFLEVBQUU7UUFDbEQsSUFBSSxPQUFPLEdBQUcsMkJBQWdCLENBQUMsT0FBa0MsQ0FBQztRQUNsRSxJQUFJLE1BQU0sR0FBSSxJQUFzQixDQUFDO1FBQ3JDLElBQUksTUFBTSxHQUFJLEtBQUssQ0FBc0MsQ0FBQztRQUUxRCxHQUFHO1lBQ0MsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsR0FBRyxNQUFNLDJCQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO2dCQUNyRixhQUFhLEVBQVEsSUFBSTtnQkFDekIsWUFBWSxFQUFTLElBQUk7Z0JBQ3pCLGtCQUFrQixFQUFHLDJCQUFnQixDQUFDLG1CQUFtQixFQUFFO2dCQUMzRCxTQUFTLEVBQVksQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUM7Z0JBQ3BGLG1CQUFtQixFQUFFOztrQkFFbkI7YUFDTCxDQUFDLENBQUM7WUFFSCxJQUFJLGdCQUFnQjtnQkFDaEIsTUFBTSxnQkFBZ0IsQ0FBQztZQUUzQixNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsS0FBOEIsQ0FBQztZQUU5RCxJQUFJLE9BQU8sSUFBSSxPQUFPLEtBQUssT0FBTyxDQUFDLE1BQU0sRUFBRTtnQkFDdkMsUUFBUTtnQkFDUiw2Q0FBNkM7Z0JBQzdDLE9BQU8sR0FBUSxPQUFPLENBQUMsTUFBTSxDQUFDO2dCQUM5QixNQUFNLEdBQVMsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksWUFBWSxDQUFDLGtCQUFrQixDQUFDO2dCQUN6RCxNQUFNLEdBQVMsWUFBWSxDQUFDLGVBQWUsQ0FBQztnQkFDNUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO2dCQUNwQyxJQUFJLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7YUFDdkM7U0FFSixRQUNNLE9BQU8sSUFBSSxPQUFPLEtBQUssT0FBTyxDQUFDLE1BQU0sRUFBRTtRQUU5QyxPQUFPLE1BQWlCLENBQUM7SUFDN0IsQ0FBQztJQUVELE9BQU8sRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUU7SUFFM0IsZ0JBQWdCLEVBQUU7UUFDZCxhQUFhLEVBQUUsS0FBSztLQUN2QjtJQUVELEtBQUssRUFBRTtRQUNILE1BQU0sQ0FBRSxNQUEyQixFQUFFLEdBQUcsSUFBSTtZQUN4QyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDMUMsQ0FBQztLQUNKO0lBRUQsbUJBQW1CLEVBQW5CLCtCQUFtQjtJQUVuQixrQkFBa0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO0lBRTdCLGtCQUFrQixFQUFFLGFBQWEsQ0FBQyxtQkFBbUI7SUFDckQsR0FBRyxFQUFpQixRQUFRO0lBQzVCLFFBQVEsRUFBWSxhQUFhO0lBQ2pDLEtBQUssRUFBZSxVQUFVO0lBQzlCLEtBQUssRUFBZSxVQUFVO0lBRTlCLDJCQUEyQixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFFcEQsV0FBVyxFQUFFO1FBQ1QsS0FBSyxFQUFFO1lBQ0gsd0JBQXdCLEVBQXhCLHFDQUF3QjtTQUMzQjtRQUVELG9DQUFvQztRQUNwQyxDQUFDO0tBQ0o7Q0FDSixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXhlY3V0aW9uQ29udGV4dCBmcm9tICcuL2V4ZWN1dGlvbi1jb250ZXh0JztcbmltcG9ydCB7IFNlcnZlck5vZGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNjcm9sbE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi90ZXN0LXJ1bi9jb21tYW5kcy9vcHRpb25zJztcbmltcG9ydCB7IGdldENsaWVudCB9IGZyb20gJy4vY2xpZW50cy1tYW5hZ2VyJztcbmltcG9ydCB7IGluaXRpYWxpemVBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2FkYXB0ZXInO1xuaW1wb3J0IHsgTGVmdFRvcFZhbHVlcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3NoYXJlZC91dGlscy92YWx1ZXMvYXhpcy12YWx1ZXMnO1xuaW1wb3J0IHsgU2Nyb2xsUmVzdWx0UHJveHlsZXNzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vY2xpZW50L2NvcmUvc2Nyb2xsJztcbmltcG9ydCAqIGFzIGRvbVV0aWxzIGZyb20gJy4vdXRpbHMvZG9tLXV0aWxzJztcbmltcG9ydCAqIGFzIHBvc2l0aW9uVXRpbHMgZnJvbSAnLi91dGlscy9wb3NpdGlvbi11dGlscyc7XG5pbXBvcnQgKiBhcyBzdHlsZVV0aWxzIGZyb20gJy4vdXRpbHMvc3R5bGUtdXRpbHMnO1xuaW1wb3J0ICogYXMgZXZlbnRVdGlscyBmcm9tICcuL3V0aWxzL2V2ZW50LXV0aWxzJztcbmltcG9ydCBjcmVhdGVFdmVudFNlcXVlbmNlIGZyb20gJy4vdXRpbHMvY3JlYXRlLWV2ZW50LXNlcXVlbmNlJztcbmltcG9ydCBjcmVhdGVNb3VzZUNsaWNrU3RyYXRlZ3kgZnJvbSAnLi9hdXRvbWF0aW9ucy9jbGljay9jcmVhdGUtbW91c2UtY2xpY2stc3RyYXRlZ3knO1xuXG5cbmluaXRpYWxpemVBZGFwdGVyKHtcbiAgICBQcm9taXNlQ3RvcjogUHJvbWlzZSxcblxuICAgIG5hdGl2ZU1ldGhvZHM6IHtcbiAgICAgICAgc2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0LFxuICAgICAgICBhcnJheUluZGV4T2Y6IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLFxuICAgICAgICBhcnJheVNwbGljZTogIEFycmF5LnByb3RvdHlwZS5zcGxpY2UsXG4gICAgICAgIGFycmF5U2xpY2U6ICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgICBhcnJheUZpbHRlcjogIEFycmF5LnByb3RvdHlwZS5maWx0ZXIsXG4gICAgICAgIG9iamVjdEFzc2lnbjogT2JqZWN0LmFzc2lnbixcbiAgICAgICAgb2JqZWN0S2V5czogICBPYmplY3Qua2V5cyxcbiAgICAgICAgZGF0ZU5vdzogICAgICBEYXRlLm5vdyxcbiAgICB9LFxuXG4gICAgc2Nyb2xsOiBhc3luYyAoZWw6IFNlcnZlck5vZGUsIG9wdHM6IFNjcm9sbE9wdGlvbnMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJDeHQgPSBFeGVjdXRpb25Db250ZXh0LmN1cnJlbnQgYXMgRXhlY3V0aW9uQ29udGV4dCB8IG51bGw7XG4gICAgICAgIGxldCByZXN1bHQgID0gbnVsbCBhcyBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgbGV0IG1hcmdpbiAgPSB2b2lkIDAgYXMgdW5kZWZpbmVkIHwgTGVmdFRvcFZhbHVlczxudW1iZXI+O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhjZXB0aW9uRGV0YWlscywgcmVzdWx0OiByZXN1bHRPYmogfSA9IGF3YWl0IGdldENsaWVudCgpLlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24oe1xuICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6ICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6ICBFeGVjdXRpb25Db250ZXh0LmdldEN1cnJlbnRDb250ZXh0SWQoKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6ICAgICAgICAgICBbeyBvYmplY3RJZDogZWwub2JqZWN0SWQgfSwgeyB2YWx1ZTogb3B0cyB9LCB7IHZhbHVlOiBtYXJnaW4gfV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogYGZ1bmN0aW9uIChlbCwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93W1wiJXByb3h5bGVzcyVcIl0uc2Nyb2xsKGVsLCBvcHRzKTtcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uRGV0YWlscylcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb25EZXRhaWxzO1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxSZXN1bHQgPSByZXN1bHRPYmoudmFsdWUgYXMgU2Nyb2xsUmVzdWx0UHJveHlsZXNzO1xuXG4gICAgICAgICAgICBpZiAoY3VyckN4dCAmJiBjdXJyQ3h0ICE9PSBjdXJyQ3h0LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86XG4gICAgICAgICAgICAgICAgLy9lbCAgICAgICAgICAgPSBmaW5kSWZyYW1lQnlXaW5kb3coY3VyckN4dCk7XG4gICAgICAgICAgICAgICAgY3VyckN4dCAgICAgID0gY3VyckN4dC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgID0gcmVzdWx0ID8/IHNjcm9sbFJlc3VsdC5zY3JvbGxXYXNQZXJmb3JtZWQ7XG4gICAgICAgICAgICAgICAgbWFyZ2luICAgICAgID0gc2Nyb2xsUmVzdWx0Lm1heFNjcm9sbE1hcmdpbjtcbiAgICAgICAgICAgICAgICBvcHRzLm9mZnNldFggPSBzY3JvbGxSZXN1bHQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBvcHRzLm9mZnNldFkgPSBzY3JvbGxSZXN1bHQub2Zmc2V0WTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjdXJyQ3h0ICYmIGN1cnJDeHQgIT09IGN1cnJDeHQucGFyZW50KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0IGFzIGJvb2xlYW47XG4gICAgfSxcblxuICAgIGJyb3dzZXI6IHsgaXNDaHJvbWU6IHRydWUgfSxcblxuICAgIGZlYXR1cmVEZXRlY3Rpb246IHtcbiAgICAgICAgaXNUb3VjaERldmljZTogZmFsc2UsXG4gICAgfSxcblxuICAgIHV0aWxzOiB7XG4gICAgICAgIGV4dGVuZCAodGFyZ2V0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCAuLi5hcmdzKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBjcmVhdGVFdmVudFNlcXVlbmNlLFxuXG4gICAgc2VuZFJlcXVlc3RUb0ZyYW1lOiAoKSA9PiB7IH0sXG5cbiAgICBnZXRFbGVtZW50RXhjZXB0VUk6IHBvc2l0aW9uVXRpbHMuZ2V0RWxlbWVudEZyb21Qb2ludCxcbiAgICBkb206ICAgICAgICAgICAgICAgIGRvbVV0aWxzLFxuICAgIHBvc2l0aW9uOiAgICAgICAgICAgcG9zaXRpb25VdGlscyxcbiAgICBzdHlsZTogICAgICAgICAgICAgIHN0eWxlVXRpbHMsXG4gICAgZXZlbnQ6ICAgICAgICAgICAgICBldmVudFV0aWxzLFxuXG4gICAgZW5zdXJlTW91c2VFdmVudEFmdGVyU2Nyb2xsOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcblxuICAgIGF1dG9tYXRpb25zOiB7XG4gICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgICBjcmVhdGVNb3VzZUNsaWNrU3RyYXRlZ3ksXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Vuc3VyZVdpbmRvd0FuZEN1cnNvckZvckxlZ2FjeVRlc3RzICgpIHtcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG4iXX0=